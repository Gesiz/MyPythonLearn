#### 说一下什么是进程什么是线程以及两者的区别:

	1.进程是操作系统资源分配的最小单位，线程是CPU调度的最小单位
	2.线程依附于进程，没有进程就没有线程，一个进程默认提供一个线程（主线程），进程可以创建多个线程
	3.进程不共享全局变量，同一个进程中的线程共享全局变量（资源竞争-->互斥锁，互斥锁可能产生死锁）
	4.进程开销大但可以利用多核（并行），线程开销小但不能利用多核（并发）
#### 关于线程资源竞争的问题:

	1. 100万次加法, 线程1和线程2谁先执行完?
	   不一定, 因为线程是由CPU进行调度的, 没有执行顺序, 所以哪个线程先执行完不一定;
	2. 线程1计算的结果一定比线程2小吗?
	   不一定, 因为无法确定哪个线程先执行完, 也没办法确定每个线程每次执行的时间, 所以无法判断两个结果大小;
	3. 某个线程计算的结果有没有可能小于100万?为什么?
	   有可能, 因为多线程共享全局变量, 有可能线程1在给全局变量赋值之后(如给全局变量赋值为num=10), 还没来得及进行下一步计算, CPU开始执行线程2, 而线程2上次执行结果小于线程1(如为num=5), 线程2继续执行, 会将5复制给全局变量num, 这样线程1就会有5次的加法计算没有产生效果, 最终线程1的计算结果小于100万, 次概率很小
#### 什么是互斥锁? 说出互斥锁的应用场景及优缺点:	

	互斥锁:	
		为保证共享数据操作的完整性, threading模块给我们提供了一个Lock类, 我们把这个类创建的对象对应于一个可称为"互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象.
	应用:
		1.互斥锁可用于多线程中有可能产生共享数据(如全局变量)竞争的场景.
	优点: 
		1.避免资源竞争
	缺点: 
		1.阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
		2.容易造成死锁
#### 什么是死锁?怎样避免死锁?

```
死锁:	在两个或多个线程中 如果每个线程锁定了其他线程试图锁定的资源 此时会造成这些线程永久阻塞 这个现象就叫死锁.	
避免死锁: 在设计程序时, 尽量减少资源竞争, 无法避免资源竞争时, 各个线程及时释放锁定的资源.
```

#### 简述并发和并行:

```
	并发: CPU在一段时间内交替执行多个任务
	并行: CPU在一段时间内只执行一个任务, 利用多个CPU完成执行多任务的功能
```

